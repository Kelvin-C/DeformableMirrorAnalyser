%  |**********************************************************************;
%  * Project           : MSci Project: PLAS-Smith-3
%  *
%  * Program name      : compare_Zdata.m
%  *
%  * Author            : Kelvin Chan
%  *
%  * Date created      : 25 MAR 2018
%  *
%  * Purpose           : Allows comparison of fitted and original data.
%  *
%  * Revision History  : v1.0
%  *
%  |**********************************************************************;

%%%%% INPUT %%%%%
% Name of the text file containing wavefront data 
% generated by 'shackhartmann.py' or 'read_xyz.py'
filename1 = 'focus.txt';

% Name of the text file containing Zernike polynomials 
% generated by 'fit_Zdata.m'
filename2 = 'focus_zernike.txt';

% The nan value used to fit the Zernike polynomials in 'fit_Zdata.m'
nan = 100;

% 1D Length of Z Matrix (N value of NxN matrix)
len = 17;

%Number of Zernike polynomials fitted
numZernike = 1000;

% Set to 1 to ignore piston/tilt/defocus. Set to 2 to ignore piston/tilt, 
% but keep defocus. Anything else to keep all values.
zernikeremove = 0;

% The data can be restricted to within a circle of this radius. 
% Change to false if no restrictions are wanted.
reduce_radius = false;

% Calculate RMS error of Zernike fitting or RMS flatness of fitted
% wavefront.
% 0 for Zernike fitting, 1 for fitted wavefront,
RMS_calc = 0;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Read the original Z data  
[X, Y, Z1] = read_Zdata(filename1, len);

% Create array showing all non-nan data
mask = Z1 ~= nan;

% Create array showing all the nan elements
rev_mask = (Z1 == nan).*nan;

% Make the Z data from Zernike polynomials
Z2 = read_zernike(filename2, len, numZernike, mask, 'standard', zernikeremove);

% Add the nan value to new data (from polynomials) to allow comparisons
% with original data.
Z2 = Z2.*mask + rev_mask;

% Reduce data size with radius
if reduce_radius ~= false
    [Z1, Z2] = reducesize(reduce_radius, nan, X, Y, Z1, Z2);
end

if RMS_calc == 0
    % Calculate the difference and its RMS between the two Z arrays.
    [rms, diff] = z1z2_rms(Z1, Z2, nan);
elseif RMS_calc == 1
    % Calculate the RMS flatness of fitted wavefront.
	[rms, diff] = self_rms(Z2, nan);
end

% Prevent plotting nan values.
Z2(Z2 == nan) = NaN;
diff(isnan(Z2)) = NaN;
X(isnan(Z2)) = NaN;
Y(isnan(Z2)) = NaN;

% Calculate maximum and minimum Z values for axis scales.
minZ2 = min(min(Z2));
maxZ2 = max(max(Z2));

disp('MIN Z2')
disp(minZ2)
disp('MAX Z2')
disp(maxZ2)
disp('RMS')
disp(rms)

% Plotting the wavefront surface
figure();
set(gcf, 'Position', [0, 0, 1000, 700])
surf(X, Y, Z2)
xlabel('$X-Distance$ $(A.U.)$', 'Interpreter', 'latex')
ylabel('$Y-Distance$ $(A.U.)$', 'Interpreter', 'latex')
zlabel('$Z$ $(\mu m)$', 'Interpreter', 'latex')
zlim([minZ2, maxZ2])
set(findall(gcf,'-property','FontSize'),'FontSize',22);
colorbar()

function [sigma, diff] = z1z2_std(Z1, Z2, nan)

    mask = Z1 ~= nan;
    n = sum(sum(mask));

    diff = (Z2 - Z1).* mask;
    diff_sqr = diff.^2;
    sigma = sqrt(sum(sum(diff_sqr))/(n-1));
end

function [sigma, diff] = self_std(Z, nan)
    
    mask = Z ~= nan;
    n = sum(sum(mask));
    
    Z = Z .* mask;
    mean_val = sum(sum(Z))/n;
    disp(mean_val)

    diff = (Z - mean_val).* mask;
    diff_sqr = diff.^2;
    sigma = sqrt(sum(sum(diff_sqr))/(n-1));
end

function [rms, diff] = z1z2_rms(Z1, Z2, nan)
    mask = Z1 ~= nan;
    n = sum(sum(mask));
    
    diff = (Z2 - Z1).^2;
    diff = diff .* mask;
    rms = sqrt(sum(sum(diff))/n);
end

function [rms, diff] = self_rms(Z, nan)
    
    mask = Z ~= nan;
    n = sum(sum(mask));
    
    Z = Z .* mask;
    mean_val = sum(sum(Z))/n;

    diff = (Z - mean_val).* mask;
    diff_sqr = diff.^2;
    rms = sqrt(sum(sum(diff_sqr))/(n));
end

function [Z1, Z2] = reducesize(r, new_val, X, Y, Z1, Z2)

    [ilen, jlen] = size(X);

    for i = 1:ilen
        for j = 1:jlen
            new_r = sqrt(X(i, j).^2 + Y(i, j).^2);
            if new_r > r
                Z1(i, j) = new_val;
                Z2(i, j) = new_val;
            end
        end
    end
end
